# 优化结果偏离初始化的原因分析

## 背景

在 `fiber_levelset.m` 的主循环中，通过求解有限元、灵敏度和速度场来更新水平集，并依靠“软约束”项 \( v_{\text{fid}} = -\lambda_{\text{fid}} (\phi - \phi_{\text{target}}) \) 维持主路径贴合初始化得到的目标水平集 `lsf_target_global`。然而实测发现，最终的零水平集明显偏离了初始化形状，且日志中长期出现 `Vfid95/Vshape95` 低于 1.5 的提示。

## 根因定位

关键问题出在 `fiber_levelset.m:303` 附近的 `lambda_fid` 估计逻辑：

```matlab
v_shape_target = 3.0;          % 常量
factor = 2.5;
lambda_fid = factor * v_shape_target / max(dev95, 1e-12);
```

- `v_shape_target` 被写死为常量 3.0，没有根据当前迭代真实的形状灵敏度强度（`Vshape95 = prctile(abs(-node_sensitivity), 95)`）进行自适应。
- 当 `|-node_sensitivity|` 的 95 分位值显著大于 3.0 时，计算出的 `lambda_fid` 偏小；`v_{\text{fid}}` 无法抵消顺着灵敏度“推开”主路径的速度，于是零水平集持续漂移。
- 偏离一旦出现，`dev95` 会增大；现有公式又与 `dev95` 成反比，导致 `lambda_fid` 进一步变小，形成负反馈。

因此，在多数迭代中 `Vfid95/Vshape95` 都低于阈值 2.5，优化阶段几乎完全由形状灵敏度主导，目标路径约束失效。

## 建议改动

将 `lambda_fid` 与实时测量的 `Vshape95` 直接挂钩，使 `v_{\text{fid}}` 具备足够的约束强度：

```matlab
band_est = bands.narrow_10h;
if any(band_est(:))
    dev95     = prctile(abs(lsf(band_est) - lsf_target_global(band_est)), 95);
    Vshape95  = prctile(abs(vshape_est(band_est)), 95);
    factor    = 2.5;                  % 目标 Vfid95 / Vshape95
    lambda_fid = factor * Vshape95 / max(dev95, 1e-12);
    lambda_fid = max(lambda_fid, lambda_min);   % 可选的下限，避免过小
else
    lambda_fid = lambda_default;      % 例如 50.0
end
```

这一调整确保：

1. `v_{\text{fid}}` 的强度随灵敏度幅值同步放大；
2. `Vfid95/Vshape95` 能稳定在预期阈值附近；
3. 主路径始终围绕初始化目标上下小幅震荡，而非系统性漂移。

如需进一步稳健，可再增加 `lambda_min`、`lambda_max` 限幅或使用指数滤波平滑 `Vshape95`。
